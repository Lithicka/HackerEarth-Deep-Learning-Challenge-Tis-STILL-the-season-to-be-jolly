# -*- coding: utf-8 -*-
"""hackerearth_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LXlvnNkVLstTeWjp0c5ZxVY10udP_Azd
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import os.path
import matplotlib.pyplot as plt
import seaborn as sns
import gc
from PIL import Image
# %matplotlib inline
from keras.applications import xception
from keras.applications import ResNet50,ResNet101
import cv2
from tqdm import tqdm
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras import backend as K
from keras import applications
from keras.models import Model
from keras import optimizers
from keras.utils import to_categorical
from keras.preprocessing.image import ImageDataGenerator
from keras.layers.normalization import BatchNormalization
from keras.utils import np_utils
from keras.callbacks import EarlyStopping
from keras.preprocessing import image

from sklearn.model_selection import StratifiedKFold , KFold ,RepeatedKFold
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

train_data = pd.read_csv("/content/drive/MyDrive/dataset (1)/train.csv") 
train_data.head()

TRAIN_PATH = '../content/drive/MyDrive/dataset (1)/train'
TEST_PATH = '../content/drive/MyDrive/dataset (1)/testt'

def get_model(IMG_SIZE):
    base_model =xception.Xception(weights='imagenet', include_top=False, input_shape=(IMG_SIZE, IMG_SIZE, 3))
    add_model = Sequential()
    add_model.add(Flatten(input_shape=base_model.output_shape[1:]))
    add_model.add(Dropout(0.3))
    add_model.add(Dense(64, activation='relu'))
    add_model.add(Dropout(0.4))

    add_model.add(Dense(6, activation='softmax'))

    model = Model(inputs=base_model.input, outputs=add_model(base_model.output))

    model.compile(loss='categorical_crossentropy', optimizer=optimizers.SGD(lr=1e-4, momentum=0.9),
                  metrics=['accuracy'])
    return model

main_pred = []
data_kfold = pd.DataFrame()

train_y = train_data.Class
train_x = train_data.drop(['Class'],axis=1)

IMG_SIZE = 128
BATCH_SIZE = 16
EPOCHS = 10
N_SPLIT = 7

train_datagen = ImageDataGenerator(width_shift_range=0.1,
                         height_shift_range=0.1,
                         zoom_range=0.3,
                         fill_mode='nearest',
                         horizontal_flip = True,
                         rescale=1./255)
validation_datagen = ImageDataGenerator(rescale = 1./255)


kfold = StratifiedKFold(n_splits=N_SPLIT,shuffle=True,random_state=42)
j = 0
for train_idx, val_idx in list(kfold.split(train_x,train_y)):
    x_train_df = train_data.iloc[train_idx]
    x_valid_df = train_data.iloc[val_idx]
    j+=1


    training_set = train_datagen.flow_from_dataframe(dataframe=x_train_df, directory=TRAIN_PATH,
                                                 x_col="Image", y_col="Class",
                                                 class_mode="categorical",
                                                 target_size=(IMG_SIZE,IMG_SIZE), batch_size=BATCH_SIZE)
    
    validation_set = validation_datagen.flow_from_dataframe(dataframe=x_valid_df, directory=TRAIN_PATH,
                                                 x_col="Image", y_col="Class",
                                                 class_mode="categorical",
                                                 target_size=(IMG_SIZE,IMG_SIZE), batch_size=BATCH_SIZE)
    
    model_test = get_model(IMG_SIZE)
    
    
    history = model_test.fit( training_set,
                              validation_data=validation_set,
                              epochs = EPOCHS,
                              steps_per_epoch=x_train_df.shape[0] // BATCH_SIZE
                            )
    
    y_pred = []
    name = []                      
    labels = (training_set.class_indices)
    labels = dict((v,k) for k,v in labels.items())
    for i in os.listdir('../content/drive/MyDrive/dataset (1)/test/'):
        name.append(i)
        i='../content/drive/MyDrive/dataset (1)/test/'+i
        img=image.load_img(i,target_size=(IMG_SIZE,IMG_SIZE,3))
        img=image.img_to_array(img)/255
        pred=model_test.predict(img.reshape(1,IMG_SIZE,IMG_SIZE,3))
        y_pred.append(labels[np.argmax(pred[0])])
                                       
    data_kfold[j] = y_pred
    gc.collect()

data_kfold

gc.collect()

name = []
for i in os.listdir('../content/drive/MyDrive/dataset (1)/test/'):
    name.append(i)
ans = pd.DataFrame(name,columns = ['Image'])

ans["Class"] = -1

import collections 
for i in range(len(data_kfold)):
    co = collections.Counter(data_kfold.loc[i])
    
    co = sorted(co.items(),key=lambda x: x[1],reverse=True)
    ans.Class.loc[i] = co[0][0]

ans.head()

ans.to_csv('Kfold_submission.csv',index=False)

!cp Kfold_submission.csv "drive/My Drive/"